1. What this controller does

This shop controller handles everything the customer/shop side can do:

Action	Route	    What happens
View all products	/products	fetch & render product list
View one product	/products/:productId	find item by id & render details
View home page      /same as product list
Add product to cart	/cart (POST)	extract product id, add to cart
View cart page	    /cart (GET)	load cart + match with product data
Delete product from cart	/cart-delete-item	remove 1 product from cart
View orders page	/orders	static render now
View checkout page	/checkout	static render now

So this file handles views + cart functionality, but NOT saving products (that's admin controller).

2. The models being used
âœ… Product model

Used to fetch products from file or DB
Has methods: fetchAll, findById

âœ… Cart model

Stores cart separately (also saved in a file)
Has methods: addProduct, deleteProduct, getCart

So products and cart are stored in two different files.

3. Function-by-function explanation
âœ… exports.getProducts
exports.getProducts = (req, res, next) => {
  const products = Product.fetchAll((products) => {
    res.render("shop/product-list", {
      prods: products,
      pageTitle: "All Products",
      path: "/products",
    });
  });
};


âœ” Loads all products
âœ” Uses callback because file reading is async
âœ” Renders product-list.ejs with products passed as prods

âœ… exports.getProduct
exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;

  Product.findById(prodId, (product) => {
    res.render("shop/product-detail", {
      product: product,
      pageTitle: product.title,
      path: "/products",
    });
  });
};


âœ” Extracts :productId from the URL
âœ” Looks up product from storage
âœ” Passes product to the view for details page

âœ… exports.getIndex

Same as getProducts but for /

exports.getIndex = (req, res, next) => {
  const products = Product.fetchAll((products) => {
    res.render("shop/index", {
      prods: products,
      pageTitle: "Shop",
      path: "/",
    });
  });
};

âœ… exports.postCart
exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId, (product) => {
    Cart.addProduct(prodId, product.price);
  });
  res.redirect("/cart");
};


âœ” Triggered when clicking "Add to Cart"
âœ” Extracts product ID from hidden input
âœ” Fetches product to get its price
âœ” Adds to cart file: { id, qty }
âœ” Redirects to cart page

âš ï¸ Notice: redirect happens immediately (no waiting for cart write)

âœ… exports.getCart (MOST IMPORTANT)
exports.getCart = (req, res, next) => {
  Cart.getCart((cart) => {
    Product.fetchAll((products) => {
      const cartProducts = [];
      for (product of products) {
        const cartProductData = cart.products.find(
          (prod) => prod.id === product.id
        );
        if (cartProductData) {
          cartProducts.push({ productData: product, qty: cartProductData.qty });
        }
      }
      res.render("shop/cart", {
        path: "/cart",
        pageTitle: "Your Cart",
        products: cartProducts,
      });
    });
  });
};


ðŸ’¡ What is happening here?

âœ… Load the cart file â†’ contains only { id, qty }
âœ… Load all products â†’ to match product details
âœ… Loop through all products
âœ… If product exists in cart, push object into array:

{
  productData: full product object,
  qty: 3
}


So the final array sent to the view looks like:

[
  { productData: { title, price, img... }, qty: 2 },
  { productData: { ... }, qty: 1 }
]

âœ… exports.postCartDeleteProduct
exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId, (product) => {
    Cart.deleteProduct(prodId, product.price);
    res.redirect("/cart");
  });
};


âœ” Gets product ID from form
âœ” Looks up price
âœ” Calls Cart.deleteProduct()
âœ” Redirects to cart again

âœ… exports.getOrders
exports.getOders = (req, res, next) => {
  res.render("shop/orders", {
    path: "/orders",
    pageTitle: "Your Orders",
  });
};


Static render for now â€” not implemented yet

âœ… exports.getCheckout

Same as above

exports.getCheckout = (req, res, next) => {
  res.render("shop/checkout", {
    path: "/checkout",
    pageTitle: "checkout",
  });
};

4. Why callbacks are used everywhere?

Because file system operations (fs.readFile) are async and Node.js doesn't wait for them.
No promises or async/await used yet â€” that comes later in the course.

5. How res.render() works

res.render(viewName, dataObject):

âœ… Chooses the .ejs file
âœ… Sends variables to template (prods, path, pageTitle)
âœ… Converts EJS to final HTML
âœ… Sends it back to browser

6. How cart storage works (important)

Cart file looks like this:

{
  "products": [
    { "id": "p1", "qty": 2 },
    { "id": "p3", "qty": 1 }
  ],
  "totalPrice": 123.45
}


So it only stores id + qty, not full product data.

That's why getCart() needs to load products from Product model again.


CART MODEL â€” FULL EXPLANATION
ðŸ“Œ Where is Cart used in the project?
Feature	Controller	How Cart is used
Add to cart	postCart (shop)	Calls Cart.addProduct()
View cart page	getCart (shop)	Calls Cart.getCart()
Remove from cart	postCartDeleteProduct (shop)	Calls Cart.deleteProduct()
Delete product (admin)	postDeleteProduct	Removes product from cart too

So Cart is the data storage layer for the shopping cart, same as Product model stores products.

ðŸ“ Where is data stored?

Cart data is stored in:

/data/cart.json


Example JSON structure:

{
  "products": [
    { "id": "123", "qty": 2 },
    { "id": "456", "qty": 1 }
  ],
  "totalPrice": 79.98
}


So cart has 2 things:

Property	Meaning
products[]	list of product IDs + quantity
totalPrice	total cost of items in cart
1ï¸âƒ£ addProduct(id, productPrice)
static addProduct(id, productPrice) { ... }

âœ… What it does

Adds a product to the cart.
If the product already exists â†’ increase quantity
If not â†’ add a new object to cart

Also updates total price.

âœ… Why static method?

Because cart is shared globally for all users (in this simple file-storage app).
We donâ€™t create new Cart() â€” we just call:

Cart.addProduct(...)


So static is correct.

âœ… Step-by-step flow

Read cart.json file (fs.readFile)

If file exists â†’ parse JSON
If not â†’ create empty cart object

Check if product already exists inside cart

If exists â†’ increase qty
If not â†’ push a new entry

Update total cart price

Write updated cart back to file (fs.writeFile)

âœ… Why read file first?

Because:

cart.json = single source of truth


We must read existing cart before modifying it â€” otherwise data would be overwritten.

âœ… Why +productPrice?

req.body values are strings, so:

+"19.99"


converts string â†’ number.

2ï¸âƒ£ deleteProduct(id, productPrice)
static deleteProduct(id, productPrice) { ... }

âœ… What it does

Removes a product from cart completely (not just 1 quantity).

Also decreases total price by productPrice Ã— qty.

âœ… Why do we need product price here?

Because cart only stores:

{ id: "...", qty: 2 }


Cart has no price info inside, so controller must send price from Product model.

That's why:

Product.findById(prodId, product => {
   Cart.deleteProduct(prodId, product.price);
})

âœ… Step-by-step flow

Read cart.json

Find product inside cart

Get its quantity

Remove it from array

Subtract (price Ã— qty) from total price

Save updated cart to file

3ï¸âƒ£ getCart(cb)
static getCart(cb) { ... }

âœ… What it does

Reads cart.json and returns the whole cart via callback.

âœ… Why callback?

Because fs.readFile() is async
So we cannot do:

return cart; âŒ


Instead we do:

Cart.getCart(cart => {
   // cart is available here
});

âœ… Step-by-step

Read cart.json asynchronously

If file missing â†’ return null

Else â†’ parse and return cart object via callback

ðŸ§  Key Concepts Used in Cart Model
Concept	Explanation
File storage	Instead of DB, JSON file is used to simulate database
Static methods	Used because cart doesn't need object instances
Callback pattern	Needed because file operations are async
Spread operator {...obj}	Used to clone objects instead of mutating
.find() & .findIndex()	Used to lookup products in cart
Unary + operator	Converts string to number
ðŸ›’ Flow Example: Add to Cart
Button "Add to Cart" clicked in UI
â†“
POST /cart
â†“
postCart controller
â†“
Product.findById()
â†“
Cart.addProduct(id, price)
â†“
cart.json updated
â†“
Redirect to /cart page

âœ… Summary of Cart Model
Method	Purpose
addProduct(id, price)	Add product or increase qty
deleteProduct(id, price)	Remove product completely
getCart(cb)	Read and return full cart data

Cart is a simple file-based mini-database just for cart data.